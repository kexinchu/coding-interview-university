
https://ku.baidu-int.com/knowledge/HFVrC7hq1Q/pKzJfZczuc/654NCwktzQ/6PNDw8MkSm6iee

## Golang
* slice和array的区别；
  * slice的内存是共享的；
  * slice无法返回函数内修改的值；
  * slice是自动扩容的；
  * slice的扩容算法；【1.17之前是1024之前2倍，1024之后1.25倍；   1.18开始256之前是2倍，超过256 newCap += (newCap + 3 * 256)/4, 逐渐降低】 【50%】
* golang是值传递还是引用传递；【只有值传递，要么传值的副本，要么传指针的副本】
* 协程
  * 进程，线程，协程 (不同点) 【20%】
  * 协程的协作式调度；【GMP】 【0%】
  * 协程的切换【50%正确】    【0%】
    * lock；
    * chan wait;
    * gc启动；
* 

## PHP 问题
* isset, empty ，is_null 区别
    empty ：只要变量是否为 "" 或者0 ，或者是false 和null ，都会返回true ； 
    isset ：是判断变量是否存在，只要你这个变量不是null 或未赋值，返回结果都是true ；
    is_null ：正好isset 的反结果。
* 编码转换
    - iconv()函数
        //iconv('目标编码', '原编码', '字符串')
        $encode = mb_detect_encoding( $str, array('ASCII','UTF-8','GB2312','GBK'));
            if ( !$encode =='UTF-8' ){
            $str = iconv('UTF-8',$encode,$str);
        }
    - mb_convert_encoding()
        //mb_convert_encoding('要转编码的字符串','目标编码','原编码')
        //mb_detect_encoding('字符串')：
        mb_convert_encoding($str,'utf-8',mb_detect_encoding($str))

    - 转成base64字符串
        base64_encode($canonical_request)
    - 转换URL编码
        urlencode('URL字符串')
        // urldecode()函数与urlencode()函数原理相反，用于解码已编码的 URL 字符串，其原理就是把十六进制字符串转换为中文字符。
* 数组的实现原理？（为什么是有序的）
1. 散列表（bucket）
2. 如何解决hash冲突
* 结合项目讲一下mvc
    MVC由Model（模型）, View（视图）和Controller（控制器）组成，PHP MVC可以更高效地管理好3个不同层的PHP代码。
        Model：数据信息存取层。
        View：view层负责将应用的数据以特定的方式展现在界面上。
        Controller：通常控制器负责从视图读取数据，控制用户输入，并向模型发送数据。

https://ku.baidu-int.com/knowledge/HFVrC7hq1Q/DS8eyHWPoh/9kl-fTNzLr/IAcGAWB1BU6jDb

## 网络
DNS   【UDP 80%】
浏览器输入URL到返回页面的过程 【80%】
TCP的握手和挥手过程 (超时)  【0%】
TCP的流量控制 【0%】
TCP和UDP的区别【50%】

## 数据库(MySQL + Redis)
1. 索引类型有哪些 + 索引的底层实现
    - 主键索引 、 唯一索引 、 普通索引 和 全文索引， 组合索引  【50%】
    - B树， B+树， 哈希索引  （B+树用的最多）   【对B+树有所了解】
    - 哈希索引的缺点
        - * hash索引只能等值查找，不能进行范围查找和部分查找。
        - * 无法用于排序与分组。
        - * 当大量值的hash码存在冲突时，其效率不一定比B+树高。
        - * 二次扫描：第一次找到满足hash值得数据，第二次对比键值取出数据。
2. ACID特性  【100%】
    - 原子性（atomicity）：事务被视为不可分割的最小单元，事务中的操作要么全部成功提交，要么失败回滚。反向执行回滚日志中的操作可实现回滚；
    - 一致性（consistency）：数据库在事务执行前后都保持一致性状态，在一致性状态下，所有事务对同一数据的访问结果是相同的；
    - 隔离性（isolation）：事务提交前，其所做的修改对其他事务不可见；
    - 持久性（durable）：事务提交后，其所做的修改会永久保存到数据库中，即使数据库发生崩溃也不会失效。
3. 并发一致性问题 （破坏了隔离性） + 如何避免 (加锁，保护隔离性)   【70%】
    丢失修改：两个事务同时修改一个数据，后修改的结果覆盖了前一个修改的结果。
    读脏数据：事务1修改了数据后事务2读取数据，但紧接着事务1撤回了修改，事务2读取的数据就是脏数据。
    不可重复读：事务1多次读取同一个数据，在事务1执行过程中，事务2修改数据并提交，之后事务1读取的数据和之前的结果不同。
    幻影读：事务1读取一个范围数据，事务2在其中插入数据后，事务1再次读取范围数据和之前不同。
4. innodb 引擎了解吗? 有什么特性?    https://zhuanlan.zhihu.com/p/109528131 【70%】
    1. 插入缓冲：
        a. 要求：非聚簇索引，索引不唯一；
        b. 插入前先检查是否在缓冲区，若是则直接插入，否则先放入insert buffer对象中。再以一定的频率进行insert buffer和非聚簇索引的子节点进行合并，可以将多个处于同一索引页的插入合并到一个操作中，大大提高了非聚簇索引的插入性能，减少了随机IO带来的性能损耗。
    2. 二次写：二次写缓存是位于系统表空间的存储，用来缓存从缓冲池到数据文件中的数据页，当数据库宕机时可以从中找到备份进行恢复；
    3. 自适应哈希：经常访问的索引会被自动生成到哈希索引中去，通过缓冲池的B+树构造而来，建立速度很快。
    4. 预读：（extent，page两种单位）
        a. 线性预读：将下一个extent读入buffer；
        b. 随机预读：将同一extent中的剩余page读入buffer。
6. 主从同步问题 
    三种主从复制方式(同步，异步，半同步)    【30%】
7.  redis 的优点？  为什么快？          【50%】
    • 速度快：基于内存；
    • 支持事务：处理都是原子性的；
    • 支持丰富的数据类型：string，list，set等；
    • 丰富的特性：可用于缓存、消息、按key设置过期时间。

    为什么快：
    • 基于内存：数据存在内存中，绝大部分的请求都是内存操作，速度很快；
    • 单进程单线程：避免了进程线程的竞争和进程切换带来的开销，也不必考虑锁的问题；
    • IO多路复用：使得单个线程可以处理多个接口的请求。
8. 基于Redis的分布式锁
9. 

【都只是了解】
1.  kafka 的模型介绍一下
2.  kafka reblance 了解吗? 哪些场景下会触发 reblance? 
3.  kafaka 高吞吐的原因?
    顺序读写 + Page Cache + 零拷贝（sendfile方法） + 分区分段 + 批量读写(网络) + 批量压缩
4.  如何保证不丢失不重复处理


## 算法题
    大文件; 随机数 的排序. 
    快排
    topK


卫雄伟
    - 代码基础    4
    - 逻辑与表达能力  3
    - 学习能力  4
    - 项目复杂度  3



