### 结构体
Go 不是面相对象的语言，没有对象，继承的概念；但是有结构体的概念：可以将一些方法和结构体关联；使代码变得简单

#### 内容
- 定义结构体 + 组合
```
type Person struct {
  Name string
  Age int
}

type Student struct {
    person *Person      // 组合
    grade int
}
```

- 初始化
  - 直接初始化
  - 构造器 - 创建一个返回所期望类型的实例的函数（类似于工厂）
  - new
    - 注意 make 只能初始化内置的数据结构: map, slice, channel 
        ```
        // 会报错
        invalid argument: cannot make Person; type must be slice, map, or channel
        ```
    - new 根据传入的类型分配一片内存空间并返回指向这片内存空间的指针 (类似C++)
```
type Saiyan struct {
  Name string
  Power int
}

// 直接初始化
goku := Saiyan{
  Name: "Goku",
  Power: 9000,
}

// 构造器
func NewSaiyan(name string, power int) Saiyan {
  return Saiyan{
    Name: name,
    Power: power,
  }
}

// new
goku := new(Saiyan)     // 返回指针
goku.name = "goku"
goku.power = 9001
```

- 作为入参使用(指针/值)
```
// 值传递，透传的副本
func Super1(s Saiyan) {
  s.Power += 10000
}
// 指针传递
func Super2(s *Saiyan) {
  s.Power += 10000
}
// 需要对指针进行修改时，函数参数需要改为指针的指针
// 不建议这么做
func Super3(s *Saiyan) {
  s = &Saiyan{"Gohan", 1000}
}

func main() {
  goku := &Saiyan{"Power", 9000}
  Super1(goku)
  fmt.Println(goku.Power)   // 9000

  goku = &Saiyan{"Power", 9000}
  Super2(goku)
  fmt.Println(goku.Power)   // 19000

  goku = &Saiyan{"Power", 9000}
  Super3(goku)
  fmt.Println(goku.Power)   // 9000
}

```

- **结构体上的函数 (或者称为类型Saiyan的一个方法)** 
- 方法中，建议将方法的接收者声明为指针，这样方便维护接收者的值
```
func (s *Saiyan) Super() {
  s.Power += 10000
}

func main() {
    goku := &Saiyan{"Goku", 9001}
    goku.Super()
    fmt.Println(goku.Power) // 将会打印出 19001
}
```
