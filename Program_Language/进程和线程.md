### 进程和线程

#### 进程
- 设计进程是为了 合理压榨CPU的性能 和 分配运行的时间段
  - CPU速度快，当任务不在执行"计算型"任务时，切换进程以避免"浪费"
    <img src="https://github.com/kexinchu/coding-interview-university/blob/main/go-language/pictures/process.jpeg" width="350px"> 

    <img src="https://github.com/kexinchu/coding-interview-university/blob/main/go-language/pictures/multi_process.jpeg" width="350px"> 

#### 线程
- 进程间的信息难以共享数据，父子进程并未共享内存，需要通过进程间通信（IPC），在进程间进行信息交换，性能开销较大。
- 创建进程（一般是调用 fork 方法）的性能开销较大。

将目光转向进程内部：
- 进程由多个 线程 (执行单元)组成，每个线程执行在进程的上下文中，共享同样的代码和全局数据
- 优势：
  - 线程之间能够非常方便、快速地共享数据。
        - 只需将数据复制到进程中的共享区域就可以了，但需要注意避免多个线程修改同一份内存。
  - 创建线程比创建进程要快 10 倍甚至更多。
        - 线程都是同一个进程下自家的孩子，像是内存页、页表等就不需要了。

#### 协程
- 协程（Coroutine）是用户态的线程；通常创建协程时，会从进程的堆中分配一段内存作为协程的栈。
- 优势：
  - 节省 CPU：避免系统内核级的线程频繁切换，造成的 CPU 资源浪费。协程是用户态的线程，用户可以自行控制协程的创建与销毁，极大程度避免了系统级线程上下文切换造成的资源浪费。
  - 节约内存：在 64 位的Linux中，一个线程需要分配 8MB 栈内存和 64MB 堆内存，系统内存的制约导致我们无法开启更多线程实现高并发。而在协程编程模式下，可以轻松有十几万协程，这是线程无法比拟的。
  - 稳定性：前面提到线程之间通过内存来共享数据，这也导致了一个问题，任何一个线程出错时，进程中的所有线程都会跟着一起崩溃。
  - 开发效率：使用协程在开发程序之中，可以很方便的将一些耗时的IO操作异步化，例如写文件、耗时 IO 请求等。

### 进程切换和线程切换的区别

#### 虚拟内存
- 虚拟内存是操作系统为每个进程提供的一种抽象，每个进程都有属于自己的、私有的、地址连续的虚拟内存，当然我们知道最终进程的数据及代码必然要放到物理内存上（页表）
- 每个进程都有自己的虚拟地址空间，进程内的所有线程共享进程的虚拟地址空间。

#### 区别
- 进程切换涉及虚拟地址空间的切换
- 进程都有自己的虚拟地址空间，把虚拟地址转换为物理地址需要查找页表，页表查找是一个很慢的过程，因此通常使用Cache来缓存常用的地址映射，这样可以加速页表查找，这个cache就是TLB，Translation Lookaside Buffer，我们不需要关心这个名字只需要知道TLB本质上就是一个cache，是用来加速页表查找的。由于每个进程都有自己的虚拟地址空间，那么显然每个进程都有自己的页表，那么当进程切换后页表也要进行切换，页表切换后TLB就失效了，cache失效导致命中率降低，那么虚拟地址转换为物理地址就会变慢，表现出来的就是程序运行会变慢，而线程切换则不会导致TLB失效，因为线程线程无需切换地址空间，