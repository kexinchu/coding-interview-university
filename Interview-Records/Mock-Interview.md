### 在过往的工作中，您使用Golang解决了哪些具体的技术问题？能否分享一个您认为最具挑战性的项目？
- 解决的具体技术问题
    - 主要用Golang搭建后端服务，不管是搜索Push还是搜索DQA，都是高峰值QPS场景，搜索Push峰值QPS接近6亿。搜索DQA峰值QPS也将近2kw.
    - 搜索DQA服务链路较长：泛化query查询 -> 物料查询 -> 策略数据查询 -> 作者信息查询 -> 站点信息查询 -> 排序阶段 -> 推荐查询 -> 页面格式化； 长尾好事比较严重 (99.5%分位好事超过350 ms)
    - 长尾耗时降低了40%

- 最具挑战性的需求： 搜索DeepQA服务重构
    - 历史冗余代码很多，逻辑复杂，业务和策略耦合严重，可维护性差
        - 20多个产品，梳理每个产品的业务逻辑，拆分耦合代码
        - 将策略与业务分开，设置单独的策略入口和策略代码接入规范，按功能封装子模块
    - Golang支持原生并发处理
    - 性能提高
        - 利用golang的并发特性，在策略数据查询的同时，并发的查询作者，站点。(封装成接口，方便后续接入更多的功能)
    - 开发过程遇到的问题：
        - Golang支持静态类型检查机制；PHP代码中，字段类型混用：bool类型和字符串类型，float类型和字符串类型， null类型和字符串
            - 通过断言的方式跑通
        - PHP和golang在浮点数计算精度不同，php是按照最高精度计算
            - 指定精度 (计算策略分的时候)
        - JSON编码的中文Unicode编码问题
            - PHP默认支持在json编码时将中文转成Unicode编码，但是在Golang中不是
            - http.HTMLEscape手动的将中文转成Unicode
        - 多条件排序
            - PHP中使用array_multisort(), 如果第一个条件相同，则会根据第二个条件来排序；但Golang内置的排序功能不能直接完成这个
            - 自定义了排序算法来实现的
    - 结果上，我们腾退了线上接近40%的实例（375个实例）


### 在设计和开发公司服务端产品时，您如何确保项目的进度和质量？您采取了哪些措施来管理和监控这些指标？
- 项目拆解 + 技术方案评审
    - 梳理项目内容并拆解成多个子任务，完成技术方案设计之后联动所有相关团队进行统一的技术方案评审（大项目会包含前端，测试，数据等不同团队，技术方案也需要相互对齐）
    - 任务拆分之后，按照子任务工作量和上下游依赖给出细分排期，方便项目进度管理（需要包含其他团队的排期）
- 定期会议管理进度
    - 定期的过进度会，对其各方进度，提前暴露风险
- 单元测试
    - 坚持编写单元测试，在子任务开发过程中确保子任务的正确性，降低后期测试成本
- 代码评审
    - 代码审查，确保团队的开发质量，减少潜在的bug


### 对于一个涉及海量用户的后端服务，如何提高其性能并确保其稳定运行？请您分享一些优化系统性能的具体经验。
- 增加Redis缓存，减少对数据库和下游服务的频繁访问；提高服务相应速度的同时减少后端压力
- 异步处理和批量操作，减少核心业务路径上的阻塞，提高系统的吞吐量
- 数据库优化

### 在处理项目需求的分析和设计时，您是如何与业务部门沟通并理解需求的？当出现模糊或冲突的需求时，您如何处理？
- 会跟业务部门持续的沟通（包括文档，会议，实时咨询）来确保对需求的正确理解；在技术方案初步完成后也需要拉齐业务同学一起评审，对其信息
- 对于模糊的需求，可以根据效果和成本提供多个方案，然后在结合成本，人力，优先级同业务部门解释清楚，帮助他们一起确定
- 对于冲突的需求，一般需要先明确业务部门的真实需求和优先级，如果跨不同的业务部门，需要多方一起对其确认优先级
- 开发的时候，需要定期向业务部门同步项目进展和风险

### 在解决系统中的技术难点时，您会采取哪些步骤？能否描述您解决一个复杂问题的完整过程？
- 问题分析：先分析问题的原因和影响范围，通过复现，debug等方法明确问题症结
- 查阅文档和资料，看一下类似的问题都有哪些解决方案
- 实验验证，通过编写小型实验代码来快速验证方案的可行性，以及可能引发的问题
- 开发和测试，明确解决方案后，通过完整的技术方案评审 -> 开发 -> 单元测试 -> 集成测试 -> 代码评审 -> 上线 流程来生效改动
- 集成测试阶段需要关注不会影响其他功能


### 请详细说明您在项目中使用Golang的经验，包括它的优势和不足。与其他语言（如Python、C++）相比，您认为Golang在哪些场景下表现更为出色？
- Golang的优势
    - 支持原生并发处理，goroutine使得并发处理非常轻量且高效。(高流量请求时)
    - 内存管理，
    - 语法简洁，开发效率高，而且能减少代码冗余
    - 支持静态类型检查
- Python 虽然很灵活，但是处理并发和性能方面不如Golang
- C++虽然性能很强，但是开发效率较低，而且对于内存管理要求较高
- PHP 也是解释型语言，比较灵活，但是它对每个请求新建进程的方式对高并发和高性能场景不够友好，而且缺乏类型检查，代码质量不易控制


### 从面向对象的角度聊聊C++和golang的区别
- 在语言特性 和 实现方法上有着显著的区别
- C++支持类 + 结构体 来封装数据和方法； 而Go仅使用结构体，更简洁
- C++通过继承机制 + 函数重载 实现代码重用和多态，多种继承方式（单继承，多继承，虚继承）； Go使用接口 + 接口嵌入来代替继承
- 封装方面，C++通过public，protected，private来控制成员权限，并引入友元函数来访问类的私有成员； Go简单的基于首字母大小写来控制方法是否私有
- C++需要手动定义析构函数释放资源，Golang提供自动回收机制，不需要手动管理内存，也就不需要析构函数


### 请分享一次您在项目中使用MySQL或其他关系型数据库的经验，您是如何优化SQL查询以提高数据库性能的？
- 在文心一言权限管理项目中，通过MySQL管理用户的权限，邀请码的存储
- 优化数据库性能：
    - 使用Redis 缓存 用户权限，减少数据库的压力 （过滤无权限用户）
    - 分表管理

### 除了MySQL外，您还提到使用过Redis。能否讲解一下这些NoSQL数据库在您的项目中是如何被应用的？
- Redis缓存
    - 在文心一言权限管理系统中，因为每次用户访问都需要校验用户权限（激活码使用也需要），所以将用户权限缓存到Redis

### 在一个远程团队的环境中，您是如何与其他团队成员有效协作的？尤其是在时区不同、面对面沟通受限的情况下，您如何确保项目顺利推进？
- 定期会议，我们会通过视频会议保持定期沟通，确保大家在项目进度和目标上达成一致
- 文档，对项目要有详细的文档和记录，方便大家查阅，避免信息gap
- 通过slack去交流

## 如果系统需要在短时间内应对突然增长的流量，您会采取哪些措施来保证系统的稳定性？您在过去的工作中有过类似的应对经验吗？
- 可拓展性设计，通过分布式架构，可以在流量突增时通过临时增加计算资源，使用负载均衡来平衡单机压力，避免雪崩
- 缓存优化：对于hot的数据，通过增加Redis降低对数据库的压力
- 限流和降级：可以对非核心功能进行限流，保证高QPS下核心业务的正常执行


### Redis和MySQL的区别，什么时候用Redis，什么时候用MySQL？
- 数据结构：
    - Redis是基于内存的key-value存储系统，支持多种数据结构（字符串，哈希，列表，集合，有序集合），访问速度块
    - MySQL是关系型数据库，使用表格形式存储数据，支持复杂查询，事务查询
- 存储方式
    - Redis存储在内存中，读写速度快，持久化较弱（可以使用快照和AOF持久化）
    - MySQL存储在磁盘上，速度慢，但支持更强大的持久化和事务管理
- 查询能力
    - redis主要是key-value查询
    - MySQL支持复杂的SQL查询，JOIN等，适合需要复杂查询的应用
- 事务支持
    - MySQL 支持ACID事务，可以保证数据的一致性和完整性
- 适用场景
    - Redis: 缓存hot数据；需要快速数据读写的场景（实时数据处理，eg 排行榜）；发布/订阅消息
    - MySQL: 关系型数据存储；复杂查询；数据完整性要求高（如金融系统）



### 设计一个短链接系统
- 将长URL映射到短URL
    - 哈希
    - 避免冲突： 随机字符串
    - 带密钥的hash算法 => 安全性

    ```go
    import (
        "crypto/md5"
        "encoding/hex"
        "math/rand"
    )

    func generateShortLink(longURL string) string {
        rand.Seed(time.Now().UnixNano())

        hash := md5.Sum([]byte(longURL))
        return hex.EncodeToString(hash[:6] + rand.Intn(6)) // 只取前6位作为短链接
    }
    ```

- 数据库
    - 表结构：短链(key)，长链(Value)，创建时间，次数等额外统计信息
    - 设置有效期，定期清理释放数据库存储
- 优化
    - Redis缓存频繁访问的短链接
    - 数据库分片：对于大规模系统
    - 水平拓展：使用负载均衡将请求分配到不同的服务器


### 如果让你设计一个秒杀系统，要怎么设计？（面试官后来提示了一下说redis又一个自增key）


### golang的http路由实现懂吗，可以描述一下吗？
- 在 Go 中，net/http 包提供了 HTTP 路由的基础设施。默认的路由实现是通过 ServeMux 类型完成的
- ServeMux路由实现
    - ServeMux 的内部实现使用了一个映射（map[string]Handler），其中键是路径，值是对应的处理程序 Handler。当收到请求时，它会遍历这些注册的路由，找到与请求路径匹配的路由并调用对应的处理程序。
- 路由匹配规则
    - 精确匹配
    - 最长前缀匹配

## HTTP 状态码
- Overview
    - 1XX: 请求已接收，继续处理
    - 2XX：成功，请求已被成功接收，理解，接受
    - 3XX：重定向，要完成请求需要进一步处理
    - 4XX：客户端错误，请求有语法错误或者请求无法实现
    - 5XX：服务端错误，服务器未能实现合法的请求
- 几个特殊状态码
    - 301 请求的网页已永久移动到新URL，客户端会缓存这个重定向
    - 302 临时重定向，客户端不缓存，未来请求依旧会每次请求旧URL
    - 400 错误请求，语法错误
    - 401 未授权
    - 403 禁止(服务器拒绝请求)
    - 404 未找到，服务器找不到请求的网页
    - 500 服务器内部错误，无法完成请求
    - 501 服务器尚未处理，比如服务器无法识别请求方法时可以返回此状态
    - 502 错误网关，服务器作为代理，从上游服务器收到无效响应
    - 503 服务不可用（超载或者宕机）

### linux ps命令 查看任务进程
- PID   进程ID
- USER  进程的所有者
- CPU   进程占用的CPU使用百分比
- MEM   进程占用的物理内存百分比
- STAT  进程状态码
- TIME  进程使用CPU的时间总和
- CMD   程序命令

### 僵尸进程
僵尸进程是指那些已经终止（即完成执行）的进程，但其进程描述符（Process Descriptor）仍然保留在系统中，等待其父进程通过系统调用（如 wait() 或 waitpid()）读取其终止状态。因为进程描述符未被释放，所以这些进程会出现在系统中，虽然它们不再执行任何代码。
- 怎么避免僵尸进程
    - 父进程可以使用 wait 或 waitpid 函数来等待子进程结束并回收它们的资源，从而避免子进程变为僵尸进程。
    - wait：会阻塞父进程，直到任意子进程终止。
    - waitpid：可以指定特定的子进程 ID 或设置非阻塞模式来等待子进程终止。

### 根据 PID 获取父进程的PID
```shell
cat /proc/${PID}/status | grep PPid
```

### HTTPS 的原理
- HTTPS 是在 HTTP 基础上加上了安全层（SSL/TLS）进行数据加密。其原理包括：
- TLS/SSL 握手：客户端和服务器之间通过 TLS 协议建立安全连接。握手过程包括身份认证（基于服务器证书），协商使用的加密算法，交换加密密钥。
- 加密数据传输：握手完成后，双方使用对称加密算法（如 AES）加密传输的数据。对称密钥是在握手过程中协商生成的。
- 身份验证：服务器通过证书认证，保证客户端访问的服务器是可信的。


### Golang高性能无GC的缓存库 bigcache 怎么实现？
- 对于那些不经常变化，但又需要频繁读取的数据，比起每次都访问数据库，更优的解决方案时放到应用的本地内存里，减少数据库I/O
    - 最简单方案： 使用map存储
- 仅使用map，在单线程下可行，但是多个goroutine 并发读写缓存时出现竞争问题
    - 使用读写锁
    ```go
    // 读
    RLock()
    v = bigcache[key]
    RUnLock()
    ```
- 上面的方案还是有问题：当读写qps很高的时候，会有一堆请求争抢同一个map锁的情况
    - 将锁的粒度减小，对map进行分片，分成多个map，并给每个map分配自己的锁 (分段锁)
    - hash来确定在哪个分片
- Golang的GC会定期扫描所有变量，当bigcache中缓存的key-value多了之后,每次扫描的开销也很大
    - 对于指针类型，golang的GC会先扫描指针，然后扫描指针指向的对象里的内容
    - golang对 key 和 value 都不含指针的map，会选择跳过，不进行gc扫描   =>  方法
    - <span style="color:red">**注意：**</span> Golang中字符串本质上是一个结构体，包含指向 []byte{} 数组的指针以及长度Len。
        - Go的字符串底层是数组，不可改变
        - 任何修改字符串的操作都会创建一个新的字符串
        - 底层指针 + 长度的方式也方便GC回收
    - 将key从string hash成uint64; 为了避免冲突，可以key + value一起hash
    - 将实际value存在一个大的 []byte{} buffer中，Map中的value存buffer里的index
- 参考：[面经](https://golangguide.top/golang/%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E7%82%B9/golang%E9%AB%98%E6%80%A7%E8%83%BD%E6%97%A0GC%E7%9A%84%E7%BC%93%E5%AD%98%E5%BA%93bigcache%E6%98%AF%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E7%9A%84.html)


面经：
https://juejin.cn/post/6967618371844046856#heading-8

https://tehub.com/a/d6RPhBudZ2

https://cloud.tencent.com/developer/article/2045555

https://www.cnblogs.com/wangzhongyang/p/17798074.html

https://www.nowcoder.com/discuss/353156428804333568

https://www.nowcoder.com/discuss/603841169302245376